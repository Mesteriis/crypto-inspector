"""
Signal Validator for E2E Testing.

Validates trading signals against actual market outcomes and calculates
accuracy metrics for different signal types.
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import StrEnum

from tests.e2e.framework.data_loader import BacktestPeriod

logger = logging.getLogger(__name__)


class SignalType(StrEnum):
    """Types of signals that can be generated."""

    STRONG_BUY = "strong_buy"
    BUY = "buy"
    NEUTRAL = "neutral"
    SELL = "sell"
    STRONG_SELL = "strong_sell"


class OutcomeType(StrEnum):
    """Outcome classifications based on returns."""

    STRONG_GAIN = "strong_gain"  # > 10%
    GAIN = "gain"  # 2-10%
    FLAT = "flat"  # -2% to 2%
    LOSS = "loss"  # -10% to -2%
    STRONG_LOSS = "strong_loss"  # < -10%


@dataclass
class SignalPrediction:
    """A prediction generated by our system."""

    signal_type: SignalType
    confidence: float  # 0-100
    timestamp: datetime
    price_at_signal: float
    indicator_values: dict = field(default_factory=dict)  # RSI, MACD, etc.
    pattern_detected: str | None = None
    raw_score: float | None = None  # Composite score 0-100


@dataclass
class ValidationResult:
    """Result of validating a prediction against actual outcome."""

    test_name: str
    symbol: str
    signal_date: datetime
    prediction: SignalPrediction
    actual_return_pct: float
    outcome_type: OutcomeType
    max_gain_pct: float
    max_drawdown_pct: float
    is_correct: bool
    is_profitable: bool
    prediction_error: float  # Difference between expected and actual
    details: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert to dictionary for reporting."""
        return {
            "test_name": self.test_name,
            "symbol": self.symbol,
            "signal_date": self.signal_date.isoformat(),
            "prediction": {
                "signal": self.prediction.signal_type.value,
                "confidence": self.prediction.confidence,
                "price": self.prediction.price_at_signal,
                "score": self.prediction.raw_score,
            },
            "outcome": {
                "return_pct": round(self.actual_return_pct, 2),
                "type": self.outcome_type.value,
                "max_gain_pct": round(self.max_gain_pct, 2),
                "max_drawdown_pct": round(self.max_drawdown_pct, 2),
            },
            "validation": {
                "is_correct": self.is_correct,
                "is_profitable": self.is_profitable,
                "prediction_error": round(self.prediction_error, 2),
            },
            "details": self.details,
        }


@dataclass
class AccuracyReport:
    """Aggregated accuracy metrics from multiple validations."""

    total_predictions: int = 0
    correct_predictions: int = 0
    profitable_predictions: int = 0

    # By signal type
    signal_counts: dict[str, int] = field(default_factory=dict)
    signal_accuracy: dict[str, float] = field(default_factory=dict)
    signal_profitability: dict[str, float] = field(default_factory=dict)

    # Overall metrics
    overall_accuracy: float = 0.0
    overall_profitability: float = 0.0
    avg_return_on_buy: float = 0.0
    avg_return_on_sell: float = 0.0
    win_rate: float = 0.0

    # Detailed results
    results: list[ValidationResult] = field(default_factory=list)

    def to_dict(self) -> dict:
        """Convert to dictionary for reporting."""
        return {
            "summary": {
                "total_predictions": self.total_predictions,
                "correct_predictions": self.correct_predictions,
                "profitable_predictions": self.profitable_predictions,
                "overall_accuracy": round(self.overall_accuracy * 100, 1),
                "overall_profitability": round(self.overall_profitability * 100, 1),
                "win_rate": round(self.win_rate * 100, 1),
            },
            "by_signal": {
                "counts": self.signal_counts,
                "accuracy": {k: round(v * 100, 1) for k, v in self.signal_accuracy.items()},
                "profitability": {k: round(v * 100, 1) for k, v in self.signal_profitability.items()},
            },
            "returns": {
                "avg_return_on_buy": round(self.avg_return_on_buy, 2),
                "avg_return_on_sell": round(self.avg_return_on_sell, 2),
            },
            "detailed_results": [r.to_dict() for r in self.results],
        }


class SignalValidator:
    """
    Validates trading signals against actual market outcomes.

    This class takes predictions generated by our analysis system and
    compares them against what actually happened in the market.
    """

    # Define what constitutes a "correct" prediction
    BUY_THRESHOLD_PCT = 2.0  # Buy signal correct if return > 2%
    SELL_THRESHOLD_PCT = -2.0  # Sell signal correct if return < -2%

    def __init__(self):
        self._results: list[ValidationResult] = []

    def classify_outcome(self, return_pct: float) -> OutcomeType:
        """
        Classify the outcome based on return percentage.

        Args:
            return_pct: Percentage return (-100 to +inf)

        Returns:
            OutcomeType classification
        """
        if return_pct > 10:
            return OutcomeType.STRONG_GAIN
        elif return_pct > 2:
            return OutcomeType.GAIN
        elif return_pct < -10:
            return OutcomeType.STRONG_LOSS
        elif return_pct < -2:
            return OutcomeType.LOSS
        else:
            return OutcomeType.FLAT

    def is_prediction_correct(
        self,
        signal: SignalType,
        return_pct: float,
    ) -> bool:
        """
        Determine if a prediction was correct based on actual return.

        Args:
            signal: The predicted signal
            return_pct: Actual return percentage

        Returns:
            True if prediction was correct
        """
        if signal in (SignalType.STRONG_BUY, SignalType.BUY):
            return return_pct > self.BUY_THRESHOLD_PCT
        elif signal in (SignalType.STRONG_SELL, SignalType.SELL):
            return return_pct < self.SELL_THRESHOLD_PCT
        else:  # NEUTRAL
            return -self.BUY_THRESHOLD_PCT < return_pct < self.BUY_THRESHOLD_PCT

    def is_prediction_profitable(
        self,
        signal: SignalType,
        return_pct: float,
    ) -> bool:
        """
        Determine if following the prediction would have been profitable.

        Args:
            signal: The predicted signal
            return_pct: Actual return percentage

        Returns:
            True if following signal would be profitable
        """
        if signal in (SignalType.STRONG_BUY, SignalType.BUY):
            return return_pct > 0
        elif signal in (SignalType.STRONG_SELL, SignalType.SELL):
            return return_pct < 0  # Short would profit
        else:  # NEUTRAL - no action taken
            return True  # Staying out is always "profitable"

    def validate_prediction(
        self,
        test_period: BacktestPeriod,
        prediction: SignalPrediction,
    ) -> ValidationResult:
        """
        Validate a single prediction against actual outcomes.

        Args:
            test_period: The test period with outcome data
            prediction: The prediction made by our system

        Returns:
            ValidationResult with accuracy metrics
        """
        actual_return = test_period.actual_return_pct or 0.0
        max_gain = test_period.max_gain_pct or 0.0
        max_drawdown = test_period.max_drawdown_pct or 0.0

        outcome_type = self.classify_outcome(actual_return)
        is_correct = self.is_prediction_correct(prediction.signal_type, actual_return)
        is_profitable = self.is_prediction_profitable(prediction.signal_type, actual_return)

        # Calculate prediction error
        # For buy signals, expected positive return
        # For sell signals, expected negative return
        if prediction.signal_type in (SignalType.STRONG_BUY, SignalType.BUY):
            expected_direction = 1
        elif prediction.signal_type in (SignalType.STRONG_SELL, SignalType.SELL):
            expected_direction = -1
        else:
            expected_direction = 0

        prediction_error = expected_direction * (-actual_return if expected_direction else actual_return)

        result = ValidationResult(
            test_name=test_period.name,
            symbol=test_period.symbol,
            signal_date=test_period.signal_date,
            prediction=prediction,
            actual_return_pct=actual_return,
            outcome_type=outcome_type,
            max_gain_pct=max_gain,
            max_drawdown_pct=max_drawdown,
            is_correct=is_correct,
            is_profitable=is_profitable,
            prediction_error=prediction_error,
            details={
                "outcome_window_days": test_period.outcome_window_days,
                "candles_used": len(test_period.input_candles),
                "outcome_candles": len(test_period.outcome_candles),
            },
        )

        self._results.append(result)
        return result

    def generate_accuracy_report(self) -> AccuracyReport:
        """
        Generate an accuracy report from all validated predictions.

        Returns:
            AccuracyReport with aggregated metrics
        """
        if not self._results:
            return AccuracyReport()

        report = AccuracyReport(
            total_predictions=len(self._results),
            results=self._results.copy(),
        )

        # Count correct and profitable
        report.correct_predictions = sum(1 for r in self._results if r.is_correct)
        report.profitable_predictions = sum(1 for r in self._results if r.is_profitable)

        # Overall rates
        report.overall_accuracy = report.correct_predictions / report.total_predictions
        report.overall_profitability = report.profitable_predictions / report.total_predictions

        # By signal type
        for signal_type in SignalType:
            signal_results = [r for r in self._results if r.prediction.signal_type == signal_type]
            if signal_results:
                report.signal_counts[signal_type.value] = len(signal_results)
                report.signal_accuracy[signal_type.value] = sum(1 for r in signal_results if r.is_correct) / len(
                    signal_results
                )
                report.signal_profitability[signal_type.value] = sum(
                    1 for r in signal_results if r.is_profitable
                ) / len(signal_results)

        # Average returns by direction
        buy_results = [r for r in self._results if r.prediction.signal_type in (SignalType.STRONG_BUY, SignalType.BUY)]
        sell_results = [
            r for r in self._results if r.prediction.signal_type in (SignalType.STRONG_SELL, SignalType.SELL)
        ]

        if buy_results:
            report.avg_return_on_buy = sum(r.actual_return_pct for r in buy_results) / len(buy_results)

        if sell_results:
            # For sells, negative return is good (short profit)
            report.avg_return_on_sell = sum(r.actual_return_pct for r in sell_results) / len(sell_results)

        # Win rate (profitable trades only, excluding neutral)
        actionable_results = [r for r in self._results if r.prediction.signal_type != SignalType.NEUTRAL]
        if actionable_results:
            report.win_rate = sum(1 for r in actionable_results if r.is_profitable) / len(actionable_results)

        return report

    def clear_results(self) -> None:
        """Clear all stored results."""
        self._results.clear()

    def get_results(self) -> list[ValidationResult]:
        """Get all validation results."""
        return self._results.copy()


def score_to_signal(score: float) -> SignalType:
    """
    Convert a composite score (0-100) to a signal type.

    Args:
        score: Composite score from ScoringEngine

    Returns:
        SignalType based on score
    """
    if score >= 75:
        return SignalType.STRONG_BUY
    elif score >= 60:
        return SignalType.BUY
    elif score <= 25:
        return SignalType.STRONG_SELL
    elif score <= 40:
        return SignalType.SELL
    else:
        return SignalType.NEUTRAL


def ta_signal_to_signal_type(ta_signal: str) -> SignalType:
    """
    Convert TA signal string to SignalType.

    Args:
        ta_signal: Signal from TAPublisher ("Strong Buy", "Buy", etc.)

    Returns:
        SignalType
    """
    mapping = {
        "Strong Buy": SignalType.STRONG_BUY,
        "Buy": SignalType.BUY,
        "Neutral": SignalType.NEUTRAL,
        "Sell": SignalType.SELL,
        "Strong Sell": SignalType.STRONG_SELL,
    }
    return mapping.get(ta_signal, SignalType.NEUTRAL)


def pattern_to_signal_type(direction: str) -> SignalType:
    """
    Convert pattern direction to SignalType.

    Args:
        direction: Pattern direction ("bullish", "bearish", "neutral")

    Returns:
        SignalType
    """
    if direction == "bullish":
        return SignalType.BUY
    elif direction == "bearish":
        return SignalType.SELL
    else:
        return SignalType.NEUTRAL
